<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamische Budget Visualisierung mit mehreren Vorhersagemethoden</title>
    <style>
        canvas {
            border: 1px solid #000;
        }
    </style>
</head>
<body>
    <canvas id="budgetChart" width="1200" height="800"></canvas>
    <script>
        const canvas = document.getElementById('budgetChart');
        const ctx = canvas.getContext('2d');
        const width = 1200;
        const height = 800;
        const margin = { top: 40, right: 300, bottom: 160, left: 60 };
        const chartWidth = width - margin.left - margin.right;
        const chartHeight = height - margin.top - margin.bottom;

        // Simulierte Budgetdaten
        const monthlyBudget = 3000;
        const yearlyBudget = monthlyBudget * 12;
        let currentDay = 0;
        let dailyExpenses = [];
        let emaData = [];
        let monthlyExpenses = Array(12).fill(0);
        let monthlyForecasts = {
            simple: Array(12).fill(null),
            ema: Array(12).fill(null),
            regression: Array(12).fill(null)
        };
        let forecastAccuracy = {
            simple: { correct: 0, total: 0 },
            ema: { correct: 0, total: 0 },
            regression: { correct: 0, total: 0 }
        };

        function generateNewDataPoint(prevValue) {
            const change = (Math.random() - 0.5) * 40;
            return Math.max(0, Math.min(200, prevValue + change));
        }

        function calculateEMA(data, period) {
            if (data.length < 2) return data;
            const k = 2 / (period + 1);
            return data.reduce((ema, price, i) => {
                ema.push(i === 0 ? price : price * k + ema[i - 1] * (1 - k));
                return ema;
            }, []);
        }

        function linearRegression(y) {
            const x = Array.from({length: y.length}, (_, i) => i);
            const n = y.length;
            const sum_x = x.reduce((a, b) => a + b, 0);
            const sum_y = y.reduce((a, b) => a + b, 0);
            const sum_xy = x.reduce((a, b, i) => a + b * y[i], 0);
            const sum_xx = x.reduce((a, b) => a + b * b, 0);
            const slope = (n * sum_xy - sum_x * sum_y) / (n * sum_xx - sum_x * sum_x);
            const intercept = (sum_y - slope * sum_x) / n;
            return { slope, intercept };
        }


        function calculateDailyForecasts() {
            const recentExpenses = dailyExpenses.slice(-30);
            
            // Simple average forecast
            const simpleAverage = recentExpenses.reduce((a, b) => a + b, 0) / recentExpenses.length;
            
            // EMA forecast
            const emaValue = emaData[emaData.length - 1];
            
            // Regression forecast
            const { slope, intercept } = linearRegression(recentExpenses);
            const regressionForecast = slope * recentExpenses.length + intercept;

            return {
                simple: simpleAverage,
                ema: emaValue,
                regression: regressionForecast
            };
        }

        function drawLine(data, color, lineWidth) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            const minValue = Math.min(...dailyExpenses);
            const maxValue = Math.max(...dailyExpenses);
            for (let i = 0; i < data.length; i++) {
                const x = margin.left + (i / 364) * chartWidth;
                const y = margin.top + chartHeight - ((data[i] - minValue) / (maxValue - minValue)) * chartHeight;
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
        }

        function fillAreas(rawData, emaData) {
            const minValue = Math.min(...rawData);
            const maxValue = Math.max(...rawData);
            for (let i = 0; i < rawData.length - 1; i++) {
                const x1 = margin.left + (i / 364) * chartWidth;
                const x2 = margin.left + ((i + 1) / 364) * chartWidth;
                const y1Raw = margin.top + chartHeight - ((rawData[i] - minValue) / (maxValue - minValue)) * chartHeight;
                const y2Raw = margin.top + chartHeight - ((rawData[i+1] - minValue) / (maxValue - minValue)) * chartHeight;
                const y1Ema = margin.top + chartHeight - ((emaData[i] - minValue) / (maxValue - minValue)) * chartHeight;
                const y2Ema = margin.top + chartHeight - ((emaData[i+1] - minValue) / (maxValue - minValue)) * chartHeight;

                ctx.beginPath();
                ctx.moveTo(x1, y1Raw);
                ctx.lineTo(x2, y2Raw);
                ctx.lineTo(x2, y2Ema);
                ctx.lineTo(x1, y1Ema);
                ctx.closePath();

                if (rawData[i] <= emaData[i]) {
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
                } else {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                }
                ctx.fill();
            }
        }

        function drawAxes() {
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            
            // X-Achse
            ctx.beginPath();
            ctx.moveTo(margin.left, height - margin.bottom);
            ctx.lineTo(width - margin.right, height - margin.bottom);
            ctx.stroke();

            // Y-Achse
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, height - margin.bottom);
            ctx.stroke();

            // X-Achsen-Beschriftung (Monate)
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            for (let i = 0; i < 12; i++) {
                const x = margin.left + (i / 11) * chartWidth;
                ctx.fillText(months[i], x, height - margin.bottom + 10);
                
                ctx.beginPath();
                ctx.moveTo(x, margin.top);
                ctx.lineTo(x, height - margin.bottom);
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.stroke();
            }

            // Y-Achsen-Beschriftung
            const minValue = 0;
            const maxValue = 200;
            const step = (maxValue - minValue) / 5;
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            for (let i = 0; i <= 5; i++) {
                const y = margin.top + (1 - i / 5) * chartHeight;
                const value = minValue + i * step;
                ctx.fillText(value.toFixed(0), margin.left - 10, y);
                
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(width - margin.right, y);
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.stroke();
            }
        }

        function calculateForecasts() {
            const currentMonth = Math.floor((currentDay - 1) / 30);
            const currentMonthExpenses = monthlyExpenses[currentMonth];
            const dayInMonth = currentDay % 30 || 30;
            const daysLeftInMonth = 30 - dayInMonth;

            // Simple forecast
            const averageDailyExpense = currentMonthExpenses / dayInMonth;
            const simpleMonthForecast = currentMonthExpenses + (averageDailyExpense * daysLeftInMonth);

            // EMA forecast
            const emaValue = emaData[emaData.length - 1];
            const emaMonthForecast = currentMonthExpenses + (emaValue * daysLeftInMonth);

            // Regression forecast
            const recentExpenses = dailyExpenses.slice(-30);
            const { slope, intercept } = linearRegression(recentExpenses);
            const regressionMonthForecast = currentMonthExpenses + 
                Array.from({length: daysLeftInMonth}, (_, i) => slope * (recentExpenses.length + i) + intercept)
                    .reduce((a, b) => a + b, 0);

            return {
                simple: simpleMonthForecast,
                ema: emaMonthForecast,
                regression: regressionMonthForecast
            };
        }

        function drawForecasts() {
            const forecasts = calculateForecasts();
            const forecastX = width - margin.right + 10;
            const forecastY = margin.top + 100;
            
            ctx.font = 'bold 14px Arial';
            ctx.fillStyle = 'black';
            ctx.textAlign = 'left';
            ctx.fillText('Prognosen:', forecastX, forecastY);
            
            ctx.font = '14px Arial';
            ctx.fillText(`Einfach: ${forecasts.simple.toFixed(2)} €`, forecastX, forecastY + 25);
            ctx.fillText(`EMA: ${forecasts.ema.toFixed(2)} €`, forecastX, forecastY + 50);
            ctx.fillText(`Regression: ${forecasts.regression.toFixed(2)} €`, forecastX, forecastY + 75);
            
            // Visuelle Indikatoren
            const indicators = Object.entries(forecasts).map(([key, value]) => 
                `${key}: ${value <= monthlyBudget ? '✅' : '❌'}`
            );
            
            indicators.forEach((indicator, index) => {
                ctx.fillText(indicator, forecastX, forecastY + 100 + index * 25);
            });
        }

        function drawVolumeIndicator() {
            const barWidth = chartWidth / 12;
            const barMaxHeight = 100;
            const barY = height - margin.bottom + 40;

            for (let i = 0; i < 12; i++) {
                const x = margin.left + i * barWidth;
                const fillHeight = (monthlyExpenses[i] / monthlyBudget) * barMaxHeight;

                // Hintergrund
                ctx.fillStyle = 'rgba(200, 200, 200, 0.5)';
                ctx.fillRect(x, barY, barWidth - 5, barMaxHeight);

                // Ausgaben
                ctx.fillStyle = 'rgba(0, 0, 255, 0.7)';
                ctx.fillRect(x, barY + barMaxHeight - fillHeight, barWidth - 5, fillHeight);

                // Budget-Linie
                ctx.beginPath();
                ctx.moveTo(x, barY);
                ctx.lineTo(x + barWidth - 5, barY);
                ctx.strokeStyle = 'green';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Prognose-Linien
                const forecastColors = { simple: 'red', ema: 'orange', regression: 'purple' };
                Object.entries(monthlyForecasts).forEach(([method, forecasts]) => {
                    if (forecasts[i] !== null) {
                        const forecastHeight = (forecasts[i] / monthlyBudget) * barMaxHeight;
                        ctx.beginPath();
                        ctx.moveTo(x, barY + barMaxHeight - forecastHeight);
                        ctx.lineTo(x + barWidth - 5, barY + barMaxHeight - forecastHeight);
                        ctx.strokeStyle = forecastColors[method];
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                });

                // Beschriftung
                ctx.fillStyle = 'black';
                ctx.textAlign = 'center';
                ctx.fillText(`${(monthlyExpenses[i]).toFixed(0)}€`, x + barWidth / 2, barY + barMaxHeight + 15);
            }
        }

        function drawAccuracyStatistics() {
            const accuracyX = width - margin.right + 10;
            const accuracyY = margin.top + 300;
            
            ctx.font = 'bold 14px Arial';
            ctx.fillStyle = 'black';
            ctx.textAlign = 'left';
            ctx.fillText('Prognosegenauigkeit:', accuracyX, accuracyY);
            
            Object.entries(forecastAccuracy).forEach(([method, accuracy], index) => {
                const accuracyPercentage = accuracy.total > 0 
                    ? (accuracy.correct / accuracy.total * 100).toFixed(2) 
                    : 'N/A';
                
                ctx.font = '14px Arial';
                ctx.fillText(`${method}: ${accuracyPercentage}%`, accuracyX, accuracyY + 25 + index * 25);
                ctx.fillText(`(${accuracy.correct}/${accuracy.total})`, accuracyX + 120, accuracyY + 25 + index * 25);
            });
        }

        function updateChart() {
            currentDay++;
            if (currentDay > 365) {
                currentDay = 1;
                dailyExpenses = [];
                emaData = [];
                monthlyExpenses = Array(12).fill(0);
                monthlyForecasts = {
                    simple: Array(12).fill(null),
                    ema: Array(12).fill(null),
                    regression: Array(12).fill(null)
                };
                forecastAccuracy = {
                    simple: { correct: 0, total: 0 },
                    ema: { correct: 0, total: 0 },
                    regression: { correct: 0, total: 0 }
                };
            }
            
            const newDataPoint = generateNewDataPoint(dailyExpenses.length > 0 ? dailyExpenses[dailyExpenses.length - 1] : 100);
            dailyExpenses.push(newDataPoint);
            emaData = calculateEMA(dailyExpenses, 14);
            
            const currentMonth = Math.floor((currentDay - 1) / 30);
            monthlyExpenses[currentMonth] += newDataPoint;

            if (currentDay % 30 === 1) {
                // Berechne die Genauigkeit am Monatsanfang für den vorherigen Monat
                const prevMonth = (currentMonth - 1 + 12) % 12;
                Object.entries(monthlyForecasts).forEach(([method, forecasts]) => {
                    if (forecasts[prevMonth] !== null) {
                        forecastAccuracy[method].total++;
                        if (Math.abs(forecasts[prevMonth] - monthlyExpenses[prevMonth]) / monthlyExpenses[prevMonth] <= 0.1) {
                            forecastAccuracy[method].correct++;
                        }
                    }
                });
            }

            if (currentDay % 30 === 15) {
                // Aktualisiere die Prognosen in der Mitte des Monats
                const forecasts = calculateForecasts();
                Object.entries(forecasts).forEach(([method, forecast]) => {
                    monthlyForecasts[method][currentMonth] = forecast;
                });
            }
            
            ctx.clearRect(0, 0, width, height);
            drawAxes();
            fillAreas(dailyExpenses, emaData);
            drawLine(dailyExpenses, 'blue', 1);
            drawLine(emaData, 'red', 2);
            drawForecasts();
            drawVolumeIndicator();
            drawAccuracyStatistics();
            
            // Legende
            ctx.font = '14px Arial';
            ctx.fillStyle = 'blue';
            ctx.fillText('Tägliche Ausgaben', width - margin.right + 10, margin.top);
            ctx.fillStyle = 'red';
            ctx.fillText('EMA', width - margin.right + 10, margin.top + 20);
            ctx.fillStyle = 'green';
            ctx.fillText('Unter Budget', width - margin.right + 10, margin.top + 40);
            ctx.fillStyle = 'red';
            ctx.fillText('Über Budget', width - margin.right + 10, margin.top + 60);

            // Aktueller Tag
            ctx.fillStyle = 'black';
            ctx.fillText(`Tag: ${currentDay}`, width - margin.right + 10, margin.top + 80);
        }

        // Initial chart drawing
        updateChart();

        // Update chart every 100ms
        setInterval(updateChart, 100);
    </script>
</body>
</html>